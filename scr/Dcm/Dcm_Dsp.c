/*============================================================================*/
/** Copyright (C) 2009-2011, iSOFT INFRASTRUCTURE SOFTWARE CO.,LTD.
 *  
 *  All rights reserved. This software is iSOFT property. Duplication 
 *  or disclosure without iSOFT written authorization is prohibited.
 *  
 *  @file       <Dcm_Dsp.c>
 *  @brief      <UDS Service - ISO14229>
 *  
 *  <This Diagnostic Communication Manager file contained UDS services
 *   which used for bootloader project>
 *  @author     <Gary Chen>
 *  @date       <2012-11-09>
 */
/*============================================================================*/

/*=======[I N C L U D E S]====================================================*/
#include "Dcm_Dsp.h"
#include "Dcm_Dsl.h"
#include "Dcm_Types.h"
#include "Dcm_Internel.h"
#include "Appl.h"

/*=======[T Y P E   D E F I N I T I O N S]====================================*/

/* data structure for program */
typedef struct
{
    /* data program start address */
    uint32 address;

    /* data program block Index(compare with parameter transfered by test) */
    uint8 blockId;

    /* if program condition is passed */
    boolean condition;
    
}Dcm_DspProgramType;

/* data structure for security access */
typedef struct
{
    /* DCM security access attempt num counter */
    uint8 attempt;

    /* if seed has requested */
    boolean seedReq;

    /* the last requested seed Id */
    uint8 seedIdReq;

    /* seed which generated by SecM module */
    SecM_SeedType seed;
    
}Dcm_DspSecurityType;

/*=======[I N T E R N A L   D A T A]==========================================*/
STATIC Dcm_DspProgramType dcmDspProgram;
STATIC Dcm_DspSecurityType dcmDspSec;

EXPORTED uint8 u8DidNumber;
/*=======[F U N C T I O N   I M P L E M E N T A T I O N S]====================*/

/******************************************************************************/
/**
 * @brief               <DCM module dsp initialize>
 * 
 * <DCM module dsp initialize> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/    
EXPORTED void Dsp_Init(void)
{
	/* set program condition is allowed */
    dcmDspProgram.condition = TRUE;
    
    /* clear erase block id */
    dcmDspProgram.blockId = 0x00u;
    
    /* clear program address */
    dcmDspProgram.address = 0x00uL;

	/* clear security access attempt num */
    dcmDspSec.attempt = 0x00u;
    
    /* set seed has not requested */
    dcmDspSec.seedReq = FALSE;
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x10 session control>
 * 
 * <handle service 0x10 session control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg10(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean positiveRspReq = TRUE;
    Dcm_SessionType sessionValue = rxBuff->pduInfo.sduDataPtr[1];
    uint8 sessionTableIndex = DCM_SESSION_NUM;
    const Dcm_SessionRowType * sessionTablePtr = Dcm_SessionRow;
    boolean sessionFind = FALSE;
    boolean processContinue = TRUE;
	//const Dcm_DslProtocolTimingRowType *stTimingParams;
    
	 //PduInfoType Info;
	 /* 
    ** if received pdu Id is function address, analyze the response request bit
    ** in subfunction 
    */
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	/* get subfunction */
        sessionValue &= DCM_RSP_CLEAR_REQUIRED;
        
        /* check if response is needed */
        if ((rxBuff->pduInfo.sduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }

	/* find session mode subfunction */
    while ((sessionTableIndex > 0) && (FALSE == sessionFind))
    {
        sessionTableIndex --;
        if (sessionValue == sessionTablePtr->sessionType)
        {
            sessionFind = TRUE;
        }
        else
        {
            sessionTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(sessionFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(sessionTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(sessionTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        if (DCM_SESSION_PROGRAMMING == sessionValue)
        {
			processContinue = FALSE;
			/* check if program condition is acceptted, other wise send NRC */
            processContinue = Dcm_CheckConditionCorrect(dcmDspProgram.condition);
			/* send pending */
            *(uint8 *)FL_BOOT_MODE = FL_EXT_PROG_REQUEST_RECEIVED;
			Dsl_StartResetTimer(DCM_P2MAX_TIME * 0x64u);
				
        }
    }

    if (TRUE == processContinue)
    {
        Dsl_SetSessionMode(sessionValue);
        
        if (TRUE == positiveRspReq)
        {
				/* set response message */	
				txBuff->pduInfo.sduDataPtr[0] = 0x50u;
				txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
				txBuff->pduInfo.sduDataPtr[2] = (uint8)DCM_P2MAX_TIME;
				txBuff->pduInfo.sduDataPtr[3] = (uint8)(((uint16) DCM_P2MAX_TIME) >> 0x08u);
				txBuff->pduInfo.sduDataPtr[4] = (uint8)DCM_P2SMAX_TIME;
				txBuff->pduInfo.sduDataPtr[5] = (uint8)(((uint16) DCM_P2SMAX_TIME) >> 0x08u);		
				txBuff->pduInfo.sduLength = 0x06u;
				Dsl_SendRsp();
        }
        else
        {
            /* reset service process */
            Dsl_ServiceFinish();
        }
    }
    
    return;	
}

/******************************************************************************/
/**
 * @brief               <handle service 0x11 ECU reset>
 * 
 * <handle service 0x11 ECU reset> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg11(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{ 
    boolean positiveRspReq = TRUE;
    Dcm_ResetType resetValue = rxBuff->pduInfo.sduDataPtr[1];
    uint8 resetTableIndex = DCM_RESET_NUM;
    const Dcm_ResetRowType * resetTablePtr = Dcm_ResetRow;
    boolean resetFind = FALSE;
    boolean processContinue = TRUE;
	 const Dcm_DslProtocolTimingRowType *stTimingParams;
	
     /* 
    ** if received pdu Id is function address, analyze the response request bit
    ** in subfunction 
    */   
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	/* get subfunction */
        resetValue &= DCM_RSP_CLEAR_REQUIRED;
        
        /* check if response is needed */
        if ((rxBuff->pduInfo.sduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }

	/* find reset mode subfunction */
    while ((resetTableIndex > 0) && (FALSE == resetFind))
    {
        resetTableIndex --;
        if (resetValue == resetTablePtr->resetType)
        {
            resetFind = TRUE;
        }
        else
        {
            resetTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(resetFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(resetTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(resetTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        
        if (TRUE == positiveRspReq)
        {
            /* set response message */	
            if (FL_APPL_UPDATED == *(uint8 *)FL_APPL_UPDATE)
            {
				txBuff->pduInfo.sduDataPtr[0] = 0x51u;
				txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];		
				txBuff->pduInfo.sduLength = 0x02u;
				Dsl_SendRsp();
            }
			*(uint8 *)FL_BOOT_MODE = 0x00u;	
			/* ECU will reset after 100ms */
			stTimingParams = Dcm_Config.DcmConfigSet->DcmDsl->DcmDslProtocol->DcmDslProtocolRow->DcmDslProtocolTimeLimit;
			Dsl_StartResetTimer(stTimingParams->TimStrP2ServerMax * 0x0Au);
        }
        else
        {
            /* reset service process */
            Dsl_ServiceFinish();
        }
    }
    
    return;
}

#if(DCM_READDID_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x22 read data by identifier>
 * 
 * <handle service 0x22 read data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg22(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint16 readDid;
    uint8 readTableIndex = DCM_READDID_NUM;
    const Dcm_ReadDidRowType * readTablePtr = Dcm_ReadDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;

	/* get read data Id */
    readDid = ((uint16)rxBuff->pduInfo.sduDataPtr[1]) << 0x08u;
    readDid += (uint16)rxBuff->pduInfo.sduDataPtr[2];
    
    /* find read data Id in configered read data table */
    while ((readTableIndex > 0) && (FALSE == didFind))
    {
        readTableIndex --;
        if (readDid == readTablePtr->DID)
        {
            didFind = TRUE;
        }
        else
        {
            readTablePtr ++;
        }
    }

	/* if did not find DID,send NRC */
    processContinue = Dcm_CheckReqOutOfRange(didFind);
   
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(readTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        
        uint16 readLength;
        
        /* excute read API,return read length */
        readLength = readTablePtr->readDataFct(&txBuff->pduInfo.sduDataPtr[3]);

	    txBuff->pduInfo.sduDataPtr[0] = 0x62u;
	    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
        txBuff->pduInfo.sduDataPtr[2] = rxBuff->pduInfo.sduDataPtr[2];
	    txBuff->pduInfo.sduLength = 0x03u + readLength;
        Dsl_SendRsp();
    }
    
    return;
}
#endif


LOCAL boolean Dsp_bLookupDID(uint16 u16DidNumber, const Dcm_DspDidType **cpstDidPtr)
{
	const Dcm_DspDidType *cpstDspDid;
	boolean bDidFoundFlag;
	
	cpstDspDid    = Dcm_Config.DcmConfigSet->DcmDsp->DcmDspDid;
	bDidFoundFlag = B_FALSE;

	while( (cpstDspDid->DcmDspDidIdentifier != u16DidNumber)&&(cpstDspDid->Arc_EOL == B_FALSE) ) 
	{
		cpstDspDid ++;
	}
	
	if( (cpstDspDid->DcmDspDidIdentifier == u16DidNumber)&&(cpstDspDid->DcmDspDidUsed != B_FALSE) ) 
	{
		bDidFoundFlag = B_TRUE;
		*cpstDidPtr = cpstDspDid;
	}

	return bDidFoundFlag;
	
}

LOCAL Dcm_NegativeResponseCodeType Dsp_ReadDidData(const Dcm_DspDidType *cpstDidPtr, PduInfoType *PduTxData)
{
	const Dcm_DspDidInfoType *cpstDspDidInfo;
	uint16 u16DataLength;
	Dcm_NegativeResponseCodeType u8ResponseCode = DCM_E_POSITIVERESPONSE;

	cpstDspDidInfo = Dcm_Config.DcmConfigSet->DcmDsp->DcmDspDidInfo;

	/* SWS_Dcm_00433 */
	if( (cpstDspDidInfo->DcmDspDidRead != NULLPTR)&&(cpstDidPtr->DcmDspDidReadDataFnc != NULLPTR) )
	{
		/*it's should use the parameter cpstDspDidInfo->DcmDspDidRead->DcmDspDidReadSessionRef.DcmDspSessionLevel
		  in the function Dsp_CheckSessionLevel()*/
		/* SWS_Dcm_00434 */
		if(Dsp_CheckSessionLevel(cpstDidPtr->sessionSupp) != FALSE)
		{
			/* SWS_Dcm_00435 */
			if(Dsp_CheckSecurityLevel(cpstDidPtr->securitySupp) != FALSE)
			{
				/* excute read API,return read length */
				u16DataLength = cpstDidPtr->DcmDspDidReadDataFnc(&PduTxData->sduDataPtr[3]);
				PduTxData->sduDataPtr[0] = 0x62u;
				PduTxData->sduDataPtr[1] = (uint8)(cpstDidPtr->DcmDspDidIdentifier >> 8);
				PduTxData->sduDataPtr[2] = (uint8)cpstDidPtr->DcmDspDidIdentifier;
				PduTxData->sduLength = 0x03u + u16DataLength;
				//PduTxData->sduLength = 0x07u;
				//Dsl_SendRsp();
			}
			else
		   {
		   	/* Not allowed in current security level */
				u8ResponseCode = DCM_E_REQUESTOUTOFRANGE;
		   }
		}
	   else
	   {
	   	/* Not allowed in current session */
			u8ResponseCode = DCM_E_REQUESTOUTOFRANGE;
	   }
	}
	else
	{
		/* Read access not configured */
		u8ResponseCode = DCM_E_REQUESTOUTOFRANGE;
	}
	return u8ResponseCode;
}
/******************************************************************************/
/**
 * @brief               <handle service 0x2E write data by identifier>
 * 
 * <handle service 0x2E write data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg2E(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint16 writeDid;
    uint8 writeTableIndex = DCM_WRITEDID_NUM;
    const Dcm_WriteDidRowType * writeTablePtr = Dcm_WriteDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;

	/* get write data Id */
    writeDid = ((uint16)rxBuff->pduInfo.sduDataPtr[1]) << 0x08u;
    writeDid += (uint16)rxBuff->pduInfo.sduDataPtr[2];
    
    /* find write data Id in configered write data table */
    while ((writeTableIndex > 0) && (FALSE == didFind))
    {
        writeTableIndex --;
        if (writeDid == writeTablePtr->DID)
        {
            didFind = TRUE;
        }
        else
        {
            writeTablePtr ++;
        }
    }

	/* if did not find DID,send NRC */
    processContinue = Dcm_CheckReqOutOfRange(didFind);
   
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(writeTablePtr->dataLength + 0x03u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(writeTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {        	
        FL_ResultType writeRet;
        
        /* excute write API,return read length */
        writeRet = writeTablePtr->writeDataFct(&rxBuff->pduInfo.sduDataPtr[3],writeTablePtr->dataLength);

		  /* if write data acceptted, wait for write pending */
        if (FL_OK != writeRet)
        {
            /* program finger print failure */
            Dsl_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
        }
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x27 securtiy access>
 * 
 * <handle service 0x27 securtiy access> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg27(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{

    Dcm_SessionType secId = rxBuff->pduInfo.sduDataPtr[1];
    uint8 secTableIndex = DCM_SECURITY_NUM;
    const Dcm_SecurityRowType * secTablePtr = Dcm_SecurityRow;
    boolean secIdFind = FALSE;
    boolean processContinue = TRUE; 

	/* find subfunction Id in configered security table */
    while ((secTableIndex > 0) && (FALSE == secIdFind))
    {
        secTableIndex --;
        if ((secId == secTablePtr->reqSeedId) || 
            (secId == secTablePtr->sendKeyId))
        {
            secIdFind = TRUE;
        }
        else
        {
            secTablePtr ++;
        }
    }
    
    /* if did not find subfunction,send NRC */ 
    processContinue = Dcm_CheckSubFuncFind(secIdFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(secTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
        uint16 checkLength;
        
        if (secId == secTablePtr->reqSeedId)
        {
            checkLength = 0x02u;
        }
        else
        {
            checkLength = 0x06u;
        }
        
        /* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(checkLength,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(secTablePtr->securitySupp);
    }
    
    if (TRUE == processContinue)
    {
    	/* check if security timer is expired */
        if (FALSE == Dsl_GetSecurityTimerExpired())
        {
            /* security access timer delay is not expired */
            Dsl_SendNcr(DCM_E_REQUIRED_TIME_DELAY_NOT_EXPIRED);
        }
        else
        {
            if (secId == secTablePtr->reqSeedId)
            {
                Dcm_RequestSeed(secTablePtr,rxBuff,txBuff);
            }
            else
            {
                Dcm_SendKey(secTablePtr,rxBuff,txBuff);
            }
        }
    }    

    return;
}
#if 0
void Dsp_UdsSecurityAccess(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
	/** @req SWS_Dcm_00252] */
	Dcm_NegativeResponseCodeType u8ResponseCode;

	u8ResponseCode = DCM_E_POSITIVERESPONSE;

	// Check sub function range (0x01 to 0x42)
	if ((pduRxData->SduDataPtr[1] >= 0x01) && (pduRxData->SduDataPtr[1] <= 0x42)) 
}
#endif
#if (DCM_COM_CONTROL_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x28 communication control>
 * 
 * <handle service 0x28 communication control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg28(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    Dcm_ComControlType controlValue = rxBuff->pduInfo.sduDataPtr[1];
    uint8 comTableIndex = DCM_COM_CONTROL_NUM;
    const Dcm_ComControlRowType * comTablePtr = Dcm_ComControlRow;
    boolean controlTypeFind = FALSE;
    boolean processContinue = TRUE;

	/* find communication control type in configered table */
    while ((comTableIndex > 0) && (FALSE == controlTypeFind))
    {
        comTableIndex --;
        
        if (controlValue == comTablePtr->controlType)
        {
            controlTypeFind = TRUE;
        }
        else
        {
            comTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(controlTypeFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(comTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunction is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(comTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        Dcm_CommunicationType communicationType = rxBuff->pduInfo.sduDataPtr[2];
        
        /* check if communication type is correct */
        if (DCM_NORMAL_COM_MESSAGES == communicationType)
        {
            /* set response message */		
    	    txBuff->pduInfo.sduDataPtr[0] = 0x68u;
    	    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];	
    	    txBuff->pduInfo.sduLength = 0x02u;
            Dsl_SendRsp();
        }
        else
        {
            /* Request out of range */
            Dsl_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
    
    return;	
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x34 request download>
 * 
 * <handle service 0x34 request download> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg34(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;
	  uint32 programSize;
    FL_ResultType requestRet;

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x0Bu,rxBuff->pduInfo.sduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        uint8 formatId = rxBuff->pduInfo.sduDataPtr[1];
        uint8 dataFormat = rxBuff->pduInfo.sduDataPtr[2];
        
        /* check if format Id and data format is correct */
        if ((0x00u == formatId) && 
            (0x44u == dataFormat))
        {
            /* set program index to 0, for service 0x36 */
            dcmDspProgram.blockId = 0x00u;

            /* get program address */
            dcmDspProgram.address =  Dcm_Get4Byte(&rxBuff->pduInfo.sduDataPtr[3]);
            /* get program length */
            programSize =  Dcm_Get4Byte(&rxBuff->pduInfo.sduDataPtr[7]);

            /* check if program address and length is correct */
            requestRet = FL_DownloadRequestValid(dcmDspProgram.address,programSize);
            
            if (FL_OK == requestRet)
            {
                /* set response message */		
        	    txBuff->pduInfo.sduDataPtr[0] = 0x74u;
        	    txBuff->pduInfo.sduDataPtr[1] = 0x20u;
        	    txBuff->pduInfo.sduDataPtr[2] = (uint8)(DCM_RX_BUF_SIZE >> 0x08u);
        	    txBuff->pduInfo.sduDataPtr[3] = (uint8)DCM_RX_BUF_SIZE;
        	    txBuff->pduInfo.sduLength = 0x04u;
                Dsl_SendRsp();
            }
            else if (FL_ERR_SEQUENCE == requestRet)
            {
                /* 0x34,0x36,0x37 service sequence is not correct */
                Dsl_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
            }
            else if ((FL_NO_FINGERPRINT == requestRet) || 
                     (FL_NO_FLASHDRIVER == requestRet))
            {
                /* fingerprint is not written */
                Dsl_SendNcr(DCM_E_UPLOAD_DOWNLOAD_NOT_ACCEPTED);
            }
            else
            {
                /* Request out of range */
                Dsl_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
            }
        }
        else
        {
            /* Request out of range */
            Dsl_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
        
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data>
 * 
 * <handle service 0x36 transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg36(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x03u,rxBuff->pduInfo.sduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* get program block index */
        uint8 dataBlockId = rxBuff->pduInfo.sduDataPtr[1];
        
        /* index programmed block index */
        if (0xFFu == dcmDspProgram.blockId)
        {
            dcmDspProgram.blockId = 0;
        }
        else
        {
            dcmDspProgram.blockId ++;
        } 
        
        if (dcmDspProgram.blockId != dataBlockId)
        {
            /* program block index is not correct */
            Dsl_SendNcr(DCM_E_WRONG_BLOCK_SEQUENCE_COUNTER);
        }
        else
        {
            uint32 programSize = (uint32)rxBuff->pduInfo.sduLength - 0x02uL;
            FL_ResultType programRet;
            
            /* excute program routine */
            programRet = FL_FlashProgramRegion (dcmDspProgram.address,&rxBuff->pduInfo.sduDataPtr[2],programSize);
            /* index program address */
            dcmDspProgram.address += programSize;
            
            if (FL_ERR_SEQUENCE == programRet)
            {
                /* 0x34,0x36,0x37 service sequence is not correct */
                Dsl_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
            }
            else if (FL_ERR_ADDR_LENGTH == programRet) 
            {
                /* program length is not the same as received in 0x34 service */
                Dsl_SendNcr(DCM_E_TRANSFER_DATA_SUSPENDED);
            }   
            else
            {
                /* wait for pending */
            } 
        }
    }
    
    return;	
}

/******************************************************************************/
/**
 * @brief               <handle service 0x37 exit transfer data>
 * 
 * <handle service 0x37 exit transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg37(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;

	/* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x01u,rxBuff->pduInfo.sduLength);

    if (TRUE == processContinue)
    {
    	/* check if service is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupp);
    }

    if (TRUE == processContinue)
    {
        FL_ResultType programRet;
        
        /* execute tranfer data exit */
        programRet = FL_ExitTransferData();
                    
        if (FL_OK == programRet)
        {
            /* set response message */		
    	    txBuff->pduInfo.sduDataPtr[0] = 0x77u;
    	    txBuff->pduInfo.sduLength = 0x01u;
            Dsl_SendRsp();
        }
        else 
        {
            /* 0x34,0x36,0x37 service sequence is not correct */
            Dsl_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
        }   
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control>
 * 
 * <handle service 0x31 routine control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg31(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean processContinue = TRUE;
    uint16 routineIdValue;
    const Dcm_RoutineControlRowType * routineTablePtr = Dcm_RoutineControlRow;
    /* get routine control type */
    uint8 routineControlValue = rxBuff->pduInfo.sduDataPtr[1];

	/* check if subfunction is start routine */
    if (DCM_START_ROUTINE != routineControlValue)
    {
    	/* if did not find subfunciton,send NRC */
        processContinue = Dcm_CheckSubFuncFind(FALSE,rxBuff);
    }
    
    if (TRUE == processContinue)
    { 
        uint8 routineTableIndex = DCM_ROUTINE_CONTROL_NUM;
        boolean routineIdFind = FALSE;
        
        /* get routine Id */
        routineIdValue = ((uint16)rxBuff->pduInfo.sduDataPtr[2]) << 0x08u; 
        routineIdValue += (uint16)rxBuff->pduInfo.sduDataPtr[3];
        
        /* find routine Id in routine table */
        while ((routineTableIndex > 0) && (FALSE == routineIdFind))
        {
            routineTableIndex --;
            if ((routineIdValue == routineTablePtr->routineId) &&
                ((DCM_RX_PHY_PDU_ID == rxBuff->pduId) || 
                 ((DCM_RX_FUNC_PDU_ID == rxBuff->pduId) && 
                  (TRUE == routineTablePtr->funcAddrSupp))))
            {
                routineIdFind = TRUE;
            }
            else
            {
                routineTablePtr ++;
            }
        }

		/* if routine Id is not find,send NRC */
        processContinue = Dcm_CheckReqOutOfRange(routineIdFind);
    }

    if (TRUE == processContinue)
    {
		/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(routineTablePtr->sessionSupp);
    }
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x03u + (uint16)routineTablePtr->optionLength,
                                             rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(routineTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* set response message */		
        txBuff->pduInfo.sduDataPtr[0] = 0x71u;
        txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
        txBuff->pduInfo.sduDataPtr[2] = rxBuff->pduInfo.sduDataPtr[2];
        txBuff->pduInfo.sduDataPtr[3] = rxBuff->pduInfo.sduDataPtr[3];
        
        /* execute routine */
        routineTablePtr->routineControl(rxBuff,txBuff);
    }
    
    return;
}


/******************************************************************************/
/**
 * @brief               <handle service 0x31 check program pre-condition>
 * 
 * <handle service 0x31 check program pre-condition> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckProgPreCondition(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    uint8 conditionLength;
    
    /* execute routine for check programming pre-conditions */
    conditionLength = FL_CheckProgPreCondition(&txBuff->pduInfo.sduDataPtr[4]);

    if (0x00u == conditionLength)
    {
    	  /* programming pre-conditions is acceptted */
        dcmDspProgram.condition = TRUE;
    }
    else
    {
    	  /* programming pre-conditions is not acceptted */
        dcmDspProgram.condition = FALSE;
    }
    
    /* set response message */			
    txBuff->pduInfo.sduLength = (PduLengthType)conditionLength + 0x04u;
    Dsl_SendRsp();
            
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 check dependency>
 * 
 * <handle service 0x31 check dependency> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckProgDependencies(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    FL_ResultType consistencyStatus;
    
    /* execute routine for check application software dependency */
    consistencyStatus = Appl_CheckConsistency();
    
    /* set response message */
    if (FL_OK == consistencyStatus)
    {
        *(uint8 *)FL_APPL_UPDATE = FL_APPL_UPDATED;
        txBuff->pduInfo.sduDataPtr[4] = 0x00u;
    }
    else
    {
        txBuff->pduInfo.sduDataPtr[4] = 0x01u;
    }
        
    txBuff->pduInfo.sduLength = 0x05u;
    
    Dsl_SendRsp();
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 checksum>
 * 
 * <handle service 0x31 checksum> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_CheckMemory(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{

    FL_ResultType checksumRet;

    /* excute checksum routine */
    checksumRet = FL_CheckSumRoutine(&rxBuff->pduInfo.sduDataPtr[4]);
    
    if (FL_OK == checksumRet)
    {
        /* wait for pending */ 
    }
    else if (FL_ERR_SEQUENCE == checksumRet)
    {
        /* checksum sequence error,no fingerprint or download data */
        Dsl_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }
    else
    {
        Dsl_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 erase block>
 * 
 * <handle service 0x31 erase block> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_EraseMemory(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{ 

    FL_ResultType eraseRet;

    uint8 eraseBlockId = rxBuff->pduInfo.sduDataPtr[5];

    /* excute erase routine */
    eraseRet = FL_EraseRoutine(eraseBlockId);
    
    if (FL_OK == eraseRet)
    {
        /* wait for pending */
    }
    else if ((FL_NO_FINGERPRINT == eraseRet) ||
             (FL_ERR_SEQUENCE == eraseRet) || 
             (FL_NO_FLASHDRIVER == eraseRet))
    {
        /* erase sequence error,no fingerprint or download data */
        Dsl_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }
    else if (FL_INVALID_DATA == eraseRet)
    {
        Dsl_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }
    else
    {
        Dsl_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x3E test precent>
 * 
 * <handle service 0x3E test precent> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg3E(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    boolean positiveRspReq = TRUE;
    boolean processContinue = TRUE;
    
    if (DCM_RX_FUNC_PDU_ID == rxBuff->pduId)
    {
    	  /* check if response needed */
        if ((rxBuff->pduInfo.sduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
    }
    
    /* check if received message length is right, other wise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.sduLength);
    
    if (TRUE == processContinue)
    {
        if (TRUE == positiveRspReq)
        {
            /* set response message */		
		    txBuff->pduInfo.sduDataPtr[0] = 0x7Eu;
		    txBuff->pduInfo.sduDataPtr[1] = 0x00u;		
		    txBuff->pduInfo.sduLength = 0x02u;
          Dsl_SendRsp();
        }
        else
        {
            /* reset service process */
            Dsl_ServiceFinish();
        }
    }
    
    return;	
}

#if (DCM_DTC_SET_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x85 set DTC control>
 * 
 * <handle service 0x85 set DTC control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_RecvMsg85(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
    Dcm_DTCSettingType DTCsetType = rxBuff->pduInfo.sduDataPtr[1];
    uint8 DTCsetTableIndex = DCM_DTC_SET_NUM;
    const Dcm_DTCSettingRowType * DTCsetTablePtr = Dcm_DTCSettingRow;
    boolean DTCsetTypeFind = FALSE;
    boolean processContinue = TRUE;

	/* find DTC setting subfunction */
    while ((DTCsetTableIndex > 0) && (FALSE == DTCsetTypeFind))
    {
        DTCsetTableIndex --;
        if (DTCsetType == DTCsetTablePtr->DTCSet)
        {
            DTCsetTypeFind = TRUE;
        }
        else
        {
            DTCsetTablePtr ++;
        }
    }
    
    /* if did not find subfunciton,send NRC */
    processContinue = Dcm_CheckSubFuncFind(DTCsetTypeFind,rxBuff);
    
    if (TRUE == processContinue)
    {
    	/* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(DTCsetTablePtr->sessionSupp);
    }  
    
    if (TRUE == processContinue)
    {
    	/* check if received message length is right, other wise send NRC */
        processContinue = Dcm_CheckMsgLength(0x02u,rxBuff->pduInfo.sduLength);
    }

    if (TRUE == processContinue)
    {
    	/* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(DTCsetTablePtr->securitySupp);
    }

    if (TRUE == processContinue)
    {
        /* set response message */		
	    txBuff->pduInfo.sduDataPtr[0] = 0xC5u;
	    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];	
	    txBuff->pduInfo.sduLength = 0x02u;
        Dsl_SendRsp();
    }
    
    return;	
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x2E write data pending finish>
 * 
 * <handle service 0x2E write data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending2E(const FL_ResultType errorCode,const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
	/* check if write data successful */
    if (FL_OK == errorCode)
    {
	    txBuff->pduInfo.sduDataPtr[0] = 0x6Eu;
	    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
        txBuff->pduInfo.sduDataPtr[2] = rxBuff->pduInfo.sduDataPtr[2];
	    txBuff->pduInfo.sduLength = 0x03u;
        Dsl_SendRsp();
    }
    else
    {
        /* program finger print failure */
        Dsl_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data pending finish>
 * 
 * <handle service 0x36 transfer data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending36(const FL_ResultType errorCode,
                   const Dcm_BuffType * rxBuff,
                   Dcm_BuffType * txBuff)
{
	/* check if program data successful */
    if (FL_OK == errorCode)
    {
	    txBuff->pduInfo.sduDataPtr[0] = 0x76u;
	    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
	    txBuff->pduInfo.sduLength = 0x02u;
       Dsl_SendRsp();
    }
    else
    {
        /* program data failure */
        Dsl_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }
    
    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control pending finish>
 * 
 * <handle service 0x31 routine control pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
void Dcm_Pending31(const FL_ResultType errorCode,
                   const Dcm_BuffType * rxBuff,
                   Dcm_BuffType * txBuff)
{
  	/* check if execute routine successful */
    if (FL_OK == errorCode)
    {
        txBuff->pduInfo.sduDataPtr[4] = 0x00u;
    }
    else
    {
        /* execute routine failure */
        txBuff->pduInfo.sduDataPtr[4] = 0x01u;
    }
    
    txBuff->pduInfo.sduDataPtr[0] = 0x71u;
    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
    txBuff->pduInfo.sduDataPtr[2] = rxBuff->pduInfo.sduDataPtr[2];
    txBuff->pduInfo.sduDataPtr[3] = rxBuff->pduInfo.sduDataPtr[3];
    txBuff->pduInfo.sduLength = 0x05u;
    Dsl_SendRsp();  
    
    return;
}

/******************************************************************************/
/**
 * @brief               <get uint32 from data buffer>
 * 
 * <get uint32 from data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>    
 */
/******************************************************************************/
STATIC uint32 Dcm_Get4Byte(const uint8* data)
{
    uint32 retData;
    
    retData = ((uint32)data[0]) << 24;
    retData += ((uint32)data[1]) << 16;
    retData += ((uint32)data[2]) << 8;
    retData += (uint32)data[3];
    
    return retData;
}

/******************************************************************************/
/**
 * @brief               <set uint32 to data buffer>
 * 
 * <set uint32 to data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>    
 */
/******************************************************************************/
STATIC void Dcm_Set4Byte(uint8* destData,const uint32 sourceData)
{
    destData[0] = (uint8)(sourceData >> 24u);
    destData[1] = (uint8)(sourceData >> 16u);
    destData[2] = (uint8)(sourceData >> 8u);
    destData[3] = (uint8)sourceData;
    
    return;
}

/**************************************************************************
Object:Dsp_UdsReadDataByIdentifier() is read data by identifier
Parameters:rxBuff:receive bufer
			  txBuff:transmit buffer
Return:none
**************************************************************************/
EXPORTED void Dsp_UdsReadDataByIdentifier(const Dcm_BuffType * rxBuff,Dcm_BuffType * txBuff)
{
	/* Autosar DCM v4.2.2 ,7.4.2.6 : SWS_Dcm_00253 */
	uint8  u8NumberOfDids;
	uint8  u8DataIndex;
	uint16 u16DidNumber;
	const Dcm_DspDidType *cpstDspDid;
	Dcm_NegativeResponseCodeType u8ResponseCode;

	//uint16 u16Counter = 0x00;

	cpstDspDid = NULLPTR;	
	u8ResponseCode = DCM_E_POSITIVERESPONSE;

	if( ((rxBuff->pduInfo.sduLength - 1u) % 2u) == 0u )
	{
		u8NumberOfDids = (uint8)((rxBuff->pduInfo.sduLength - 1u) / 2u);
		u8DidNumber = u8NumberOfDids;
		
		for(u8DataIndex = 0;u8DataIndex < u8NumberOfDids;u8DataIndex ++)
		{
			u16DidNumber  = (uint16)((uint16)rxBuff->pduInfo.sduDataPtr[1 + (u8DataIndex * 2)] << 8);
			u16DidNumber |= (uint16)rxBuff->pduInfo.sduDataPtr[2 + (u8DataIndex * 2)];
			
			/* SWS_Dcm_00438,SWS_Dcm_00561 */
			if(Dsp_bLookupDID(u16DidNumber,&cpstDspDid))
			{
				u8ResponseCode = Dsp_ReadDidData(cpstDspDid, &txBuff->pduInfo);
				if(u8ResponseCode == DCM_E_POSITIVERESPONSE)
				{
					/* send the positive response */
					Dsl_SendRsp();
				}
				else
				{
					/* do nothing */
				}
			}
			else
			{
				/* Request out of range */
				u8ResponseCode = DCM_E_REQUEST_OUT_OF_RANGE;
			}		
		}
	}
	else
	{
		/* service length is not correct */
      u8ResponseCode = DCM_E_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT;
	}

	if( u8ResponseCode !=DCM_E_POSITIVERESPONSE )
	{
		/* send the NRC */
		Dsl_SendNcr(u8ResponseCode);
	}
	else
	{
		/* do nothing */
	}
}

/******************************************************************************/
/**
 * @brief               <check if session mode is support>
 * 
 * <check if session mode is support> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <sessionTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
EXPORTED boolean Dsp_CheckSessionLevel(const Dcm_SessionType * sessionTable)
{
    boolean ret = FALSE;
    uint8 sessionIndex = DCM_SESSION_SUPPORT_NUM;
    
    for (sessionIndex = 0; 
         (sessionIndex < DCM_SESSION_SUPPORT_NUM) && (FALSE == ret); 
         sessionIndex ++)
    {
        if (dcmRunTime.curSession == sessionTable[sessionIndex])
        {
            ret = TRUE;
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if security level if supportted>
 * 
 * <check if security level if supportted> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secLevTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
EXPORTED boolean Dsp_CheckSecurityLevel(const Dcm_SecurityType * secLevTable)
{
    boolean ret = FALSE;
    uint8 secIndex;
    
    for (secIndex = 0; 
         (secIndex < DCM_SECURITY_SUPPORT_NUM) && (FALSE == ret); 
         secIndex ++)
    {
        if (dcmRunTime.securityLevel == secLevTable[secIndex])
        {
            ret = TRUE;
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if security level if supportted>
 * 
 * <check if security level if supportted> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secLevTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
EXPORTED uint16 Dsp_ReadVIN(uint8 *readData)
{
	uint16 readLength = 0x00uL;
	//uint8 u8Data[17];
	//uint8 *u8Data;

	//u8Data[17] = (uint8)"12345678901234567";
	//readData = u8Data;
	readLength = 17u;

	return readLength;
}
/******************************************************************************/
/**
 * @brief               <check if subfunction is supported in current session>
 * 
 * <check if subfunction is supported in current session> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <sessionTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncSession(const Dcm_SessionType * sessionTable)
{
    boolean ret;

    ret = Dsp_CheckSessionLevel(sessionTable);
    
    if (FALSE == ret)
    {
        /* subfunction is not supportted in active session*/
        Dsl_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED_INACTIVE_SESSION);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if receive message length is correct>
 * 
 * <check if receive message length is correct> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <minlength (IN),receivedLength (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckMsgLength(const uint16 minlength,
                                  const uint16 receivedLength)
{
    boolean ret = TRUE;
    
    if (receivedLength < minlength)
    {
        ret = FALSE;
        
        /* service length is not correct */
        Dsl_SendNcr(DCM_E_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    }

    return ret;
}


/******************************************************************************/
/**
 * @brief               <check if service is supportted in current security level>
 * 
 * <check if service is supportted in current security level> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secLevTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSecurityCondition(const Dcm_SecurityType * secLevTable)
{
    boolean ret; 

    ret = Dsp_CheckSecurityLevel(secLevTable);
    
    if (FALSE == ret)
    {
        /* security condition is not correct */
        Dsl_SendNcr(DCM_E_SECURITY_ACCESS_DENIED);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if subfunction is finded>
 * 
 * <check if subfunction is finded> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <find (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncFind(const boolean find,const Dcm_BuffType * rxBuff)
{
    boolean ret = find; 
    
    if (FALSE == ret)
    {
        if (DCM_RX_PHY_PDU_ID == rxBuff->pduId)
        {
            /* subfunction is not supportted */
            Dsl_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED);
        }
        else
        {
            /* reset service process */
            Dsl_ServiceFinish();
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if condition is correct in service>
 * 
 * <check if condition is correct in service> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckConditionCorrect(const boolean condition)
{
    boolean ret = condition; 
    
    if (FALSE == ret)
    {
        /* condition is not correct */
        Dsl_SendNcr(DCM_E_CONDITION_NOT_CORRECT);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if request is out of range>
 * 
 * <check if request is out of range> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>    
 */
/******************************************************************************/
STATIC boolean Dcm_CheckReqOutOfRange(const boolean condition)
{
    boolean ret = condition; 
    
    if (FALSE == ret)
    {
        /* Request out of range */
        Dsl_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <execute generate seed>
 * 
 * <execute generate seed> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
STATIC void Dcm_RequestSeed(const Dcm_SecurityRowType * secTablePtr,
                            const Dcm_BuffType * rxBuff,
                            Dcm_BuffType * txBuff)
{
	/* check if seed has requested */
    if ((TRUE == dcmDspSec.seedReq) && 
        (dcmDspSec.seedIdReq == secTablePtr->reqSeedId))
    {
    	/* if seed has requested, seed is 0x00 */
        dcmDspSec.seed.seedX = 0x00uL;
        //dcmDspSec.seed.seedY = 0x00uL;
    }
    else
    {
        dcmDspSec.seedReq = TRUE;
        
        /* record received seed Id */
        dcmDspSec.seedIdReq = secTablePtr->reqSeedId;
        
        /* execute generate seed */
        (void)secTablePtr->generateSeed(&dcmDspSec.seed);
    }
    
    /* set response message */
    txBuff->pduInfo.sduDataPtr[0] = 0x67u;
    txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
    Dcm_Set4Byte(&txBuff->pduInfo.sduDataPtr[2],dcmDspSec.seed.seedX);
    txBuff->pduInfo.sduLength = 0x06u;
    Dsl_SendRsp();

    return;
}

/******************************************************************************/
/**
 * @brief               <execute compare key>
 * 
 * <execute compare key> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>    
 */
/******************************************************************************/
STATIC void Dcm_SendKey(const Dcm_SecurityRowType * secTablePtr,
                        const Dcm_BuffType * rxBuff,
                        Dcm_BuffType * txBuff)
{
	 /* check if seed has requested */
    if ((TRUE == dcmDspSec.seedReq) && 
        (dcmDspSec.seedIdReq == secTablePtr->reqSeedId))
    {
        SecM_KeyType receivedKey;
        SecM_StatusType compareStatus;

        dcmDspSec.seedReq = FALSE;
        
        /* get received key */
        receivedKey = (SecM_KeyType)Dcm_Get4Byte(&rxBuff->pduInfo.sduDataPtr[2]);
        
        /* compare key */
        compareStatus = secTablePtr->compareKey(receivedKey,dcmDspSec.seed);

		  /* check if compare key successful */
        if (SECM_OK == compareStatus)
        {
        	   /* set to requested security level */
            Dsl_SetSecurityLevel(secTablePtr->secAccessLevel);
            
            /* clear security access attempt num */
            dcmDspSec.attempt = 0x00u;
            
            /* set response message */
            txBuff->pduInfo.sduDataPtr[0] = 0x67u;
            txBuff->pduInfo.sduDataPtr[1] = rxBuff->pduInfo.sduDataPtr[1];
            txBuff->pduInfo.sduLength = 0x02u;
            Dsl_SendRsp();
        }
        else
        {
        	   /* set to requested security level */
            Dsl_SetSecurityLevel(DCM_SECURITY_LOCKED);
            
        	   /* compare key fialed, increat security access attempt num */
            dcmDspSec.attempt ++;
			   /* security access attempt num is overflow,*/
            if(dcmDspSec.attempt < DCM_SECURITY_ATTEMPT_NUM)
            {
                /* the sent key is invalid */
                Dsl_SendNcr(DCM_E_INVALID_KEY);   
            }
            else
            {
                /* num of security access is exceeded */
                dcmDspSec.attempt = 0;
                
                /* start security timer */
                Dsl_StartSecurityTimer(DCM_SECURITY_TIME);
                
                /* send NRC */
                Dsl_SendNcr(DCM_E_EXCEEDED_NUMBER_OF_ATTEMPTS);
            }
        }
    }
    else
    {
        /* seed is not sent */
        Dsl_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }

    return;
}

Std_ReturnType vSecurityLevel_1_GetSeed (uint8 *seed)
{
    *seed = 0xEF;
    return E_OK;
}

Std_ReturnType vSecurityLevel_1_CompKey (uint8 *key)
{
    if(*key == 0xEF)
    {
        return E_OK;
    }
    else
    {
        return E_NOT_OK;
    }
}

Std_ReturnType vSecurityLevel_Locked_GetSeed (uint8 *seed)
{
    *seed = 0xEF;
    return E_OK;
}

Std_ReturnType vSecurityLevel_Locked_CompKey (uint8 *key)
{
    if(*key == 0xEF)
    {
        return E_OK;
    }
    else
    {
        return E_NOT_OK;
    }
}
/*=======[R E V I S I O N   H I S T O R Y]====================================*/
/** <VERSION>  <DATE>  <AUTHOR>     <REVISION LOG>
 *  V1.0    20121109    Gary       Initial version
 */
/*=======[E N D   O F   F I L E]==============================================*/
